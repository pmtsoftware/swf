{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE NamedFieldPuns #-}

module Webauthn.PendingCeremonies
    ( PendingCeremoniesConfig (..)
    , defaultPendingCeremoniesConfig
    , newPendingCeremonies
    , PendingCeremonies
    , insertPendingRegistration
    , insertPendingAuthentication
    , getPendingRegistration
    , getPendingAuthentication
    )
where

import Relude hiding (get)

import Control.Concurrent (forkIO, threadDelay)
import qualified Control.Concurrent.STM as STM
import qualified Crypto.WebAuthn as WA
import Data.Binary (Binary)
import qualified Data.Binary as Binary
import qualified Data.Binary.Get as Binary
import qualified Data.Binary.Put as Binary
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Map as Map
import System.Clock (Clock (Realtime), TimeSpec (sec), getTime)

-- | Configuration for the pending ceremony management
data PendingCeremoniesConfig = PendingCeremoniesConfig
    {
        -- | The minimum time in seconds that a pending operation should be waited for to complete
        validTime :: Int64,
        -- | The interval in seconds at which pending operations should be checked for expiration
        expireInterval :: Int,
        -- | The number of random bytes the challenge should contain. Should be at least 16
        challengeBytes :: Int
    }

-- | The default config: Ceremonies are expired after 5 minutes, they get
-- cleaned up every 10 seconds, and challenges are 16 bytes long
defaultPendingCeremoniesConfig :: PendingCeremoniesConfig
defaultPendingCeremoniesConfig =
    PendingCeremoniesConfig
    { validTime = 5 * 60
    , expireInterval = 10
    , challengeBytes = 16
    }

-- | An 'M.Challenge' that expires after a certain time.
data ExpiringChallenge = ExpiringChallenge
    {
        -- | The unix epoch seconds after which this challenge is expired
        -- This is exposed to the clients, but this is not a vulnerability, see
        -- <https://security.stackexchange.com/questions/187316/is-exposing-the-server-time-a-security-risk>.
        -- This field intentionally comes _before_ the 'randomness' field, such that
        -- the derived 'Ord' instance orders challenges according to their expiration
        -- time, which allows much faster periodic expiration
        expiredAfter :: Int64,
        -- | The random part of the challenge
        randomness :: WA.Challenge
    }
    deriving (Show, Eq, Ord)

-- | The current time in seconds for challenge expiration
getNow :: IO Int64
getNow =
    -- We're only interested in second-resolution
    sec
        -- While realtime can have backwards jumps with leap seconds, that's not a
        -- problem since our expiration times are on the order of minutes, and it's
        -- pretty clear that realtime isn't a security problem, see
        -- <https://security.stackexchange.com/questions/187316/is-exposing-the-server-time-a-security-risk>
        <$> getTime Realtime

isExpired :: Int64 -> ExpiringChallenge -> Bool
isExpired now challenge = expiredAfter challenge < now

-- | This instance is used to turn an 'ExpiringChallenge' into an 'M.Challenge' and back
instance Binary ExpiringChallenge where
    put ExpiringChallenge {expiredAfter, randomness} = do
        Binary.putInt64le expiredAfter
        Binary.putByteString (WA.unChallenge randomness)
    get = ExpiringChallenge
        <$> Binary.getInt64le
        <*> (WA.Challenge . LBS.toStrict <$> Binary.getRemainingLazyByteString)

type Pendings c = STM.TVar (Map ExpiringChallenge (WA.CredentialOptions c))

-- | The data structure that stores pending ceremonies in memory
data PendingCeremonies = PendingCeremonies
    { pendingRegistrations :: Pendings 'WA.Registration
    , pendingAuthentications :: Pendings 'WA.Authentication
    , pendingConfig :: PendingCeremoniesConfig
    }

-- | Stores a new pending registration ceremony in memory along with its
-- 'M.CredentialOptions' options. The challenge to be used for the options is
-- generated by this function.
insertPendingRegistration ::
    PendingCeremonies ->
    -- | Given a generated challenge, what are the complete options. The challenge
    -- needs to be used for the options 'M.corChallenge' field
    (WA.Challenge -> WA.CredentialOptions 'WA.Registration) ->
    IO (WA.CredentialOptions 'WA.Registration)
insertPendingRegistration PendingCeremonies {..} = insert pendingConfig pendingRegistrations

-- | Stores a new pending authentication ceremony in memory along with its
-- 'M.CredentialOptions' options. The challenge to be used for the options is
-- generated by this function.
insertPendingAuthentication ::
    PendingCeremonies ->
    -- | Given a generated challenge, what are the complete options. The challenge
    -- needs to be used for the options 'M.coaChallenge' field
    (WA.Challenge -> WA.CredentialOptions 'WA.Authentication) ->
    IO (WA.CredentialOptions 'WA.Authentication)
insertPendingAuthentication PendingCeremonies {..} = insert pendingConfig pendingAuthentications

-- | Generic shared implementation of the 'insertPendingRegistration' and
-- 'insertPendingAuthentication' functions
insert ::
    PendingCeremoniesConfig ->
    Pendings c ->
    (WA.Challenge -> WA.CredentialOptions c) ->
    IO (WA.CredentialOptions c)
insert cfg pending create = do
    expiringChallenge <- generateExpiringChallenge
    let challenge = WA.Challenge $ LBS.toStrict $ Binary.encode expiringChallenge
        value = create challenge
    STM.atomically $ STM.modifyTVar pending $ Map.insert expiringChallenge value
    pure value
    where
        generateExpiringChallenge :: IO ExpiringChallenge
        generateExpiringChallenge = do
            now <- getNow
            -- We only look at seconds, not nanoseconds
            -- 1 hour expiration time, no real reason
            let expiredAfter = now + validTime cfg

            randomness <- WA.generateChallenge

            pure $ ExpiringChallenge {..}

-- | Gets a pending registration ceremony in memory along with its 'M.CredentialOptions',
-- given a 'M.Credential' which contains the challenge previously generated by 'insertPendingRegistration'.
-- This deletes the options from memory again. If the challenge is expired an error is returned
getPendingRegistration ::
    PendingCeremonies ->
    -- The credential that was received as a reply
    WA.Credential 'WA.Registration raw ->
    IO (Either String (WA.CredentialOptions 'WA.Registration))
getPendingRegistration pending cred = get (pendingRegistrations pending) (WA.ccdChallenge $ WA.arrClientData $ WA.cResponse cred)

-- | Gets a pending registration ceremony in memory along with its 'M.CredentialOptions',
-- given a 'M.Credential' which contains the challenge previously generated by 'insertPendingRegistration'.
-- This deletes the options from memory again. If the challenge is expired an error is returned
getPendingAuthentication ::
    PendingCeremonies ->
    -- The credential that was received as a reply
    WA.Credential 'WA.Authentication raw ->
    IO (Either String (WA.CredentialOptions 'WA.Authentication))
getPendingAuthentication pending cred = get (pendingAuthentications pending) (WA.ccdChallenge $ WA.araClientData $ WA.cResponse cred)

-- | Generic shared implementation of the 'getPendingRegistration' and
-- 'getPendingAuthentication' functions
get ::
    Pendings c ->
    WA.Challenge ->
    IO (Either String (WA.CredentialOptions c))
get pending (WA.Challenge challenge) = case Binary.decodeOrFail (LBS.fromStrict challenge) of
    Left (_, _, err) -> pure $ Left $ "Decoding challenge failed: " <> err
    Right (_, _, expiringChallenge) -> do
        now <- getNow
        -- The client has to send back the correct expired time, so we don't
        -- even need to do an STM action if it's expired already
        -- This is safe because if the expired time is wrong for a specific
        -- challenge, it would just not be found in the map in the following step
        if isExpired now expiringChallenge
        then pure $ Left "Challenge expired"
        else STM.atomically $ do
            contents <- STM.readTVar pending
            let result = Map.lookup expiringChallenge contents
            -- Delete the challenge, it should only be usable a single time
            STM.writeTVar pending $ Map.delete expiringChallenge contents
            pure $ case result of
                Just options -> Right options
                Nothing -> Left "Challenge not known or expired"

-- | Creates a new managed 'PendingCeremonies' value that tracks pending webauthn
-- ceremonies according to the given 'PendingCeremoniesConfig'.
-- The result can be used with functions 'insertPendingRegistration',
-- 'insertPendingAuthentication', 'getPendingRegistration' and
-- 'getPendingAuthentication'
newPendingCeremonies :: PendingCeremoniesConfig -> IO PendingCeremonies
newPendingCeremonies pendingConfig = do
    -- [(spec)](https://www.w3.org/TR/webauthn-2/#sctn-cryptographic-challenges)
    -- In order to prevent replay attacks, the challenges MUST contain enough entropy
    -- to make guessing them infeasible. Challenges SHOULD therefore be at least 16 bytes long.
    when (challengeBytes pendingConfig < 16) $ fail "newPendingCeremonies: challengeBytes needs to be at least 16 [bytes]"
    pendingRegistrations <- STM.newTVarIO Map.empty
    pendingAuthentications <- STM.newTVarIO Map.empty
    let pendings = PendingCeremonies {..}
    -- Clean up pending ceremonies over time to prevent leaking memory for
    -- ceremonies that are only started but never finished
    _ <- forkIO $ expireLoop pendings
    pure pendings
    where
        expireLoop :: PendingCeremonies -> IO ()
        expireLoop pending = forever $ do
            now <- getNow
            expireChallenges now (pendingRegistrations pending)
            expireChallenges now (pendingAuthentications pending)
            threadDelay (1000 * 1000 * expireInterval pendingConfig)

        expireChallenges :: Int64 -> Pendings c -> IO ()
        expireChallenges now pendings = do
            expired <- STM.atomically $ do
                ops <- STM.readTVar pendings
                -- 'Map.spanAntitone' is an efficient (O(log n)) way to split the map into a
                -- set of expired and a set of still valid ceremonies, this is only
                -- possible because 'ExpiringChallenge's 'Ord' instance orders according
                -- to 'expiredAfter' time first
                let (expired, valid) = Map.spanAntitone (isExpired now) ops
                STM.writeTVar pendings valid
                pure expired
            -- TODO: Do something less invasive than printing the removed options,
            -- this is desirable when this module is included as part of the library,
            -- and we no longer want to write to stdout.
            unless (Map.null expired) $ putStrLn $ "Removed these expired pending ceremonies: " <> show expired
